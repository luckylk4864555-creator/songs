<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Multi-Block Game</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; touch-action: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        #score { position: absolute; top: 15px; left: 15px; color: white; font-size: 22px; font-weight: bold; z-index: 10; }
        #game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center; display: none; z-index: 20; background: rgba(0, 0, 0, 0.9); padding: 30px; border-radius: 15px; width: 80%; max-width: 300px; }
        button { padding: 15px 30px; font-size: 18px; cursor: pointer; background: #27ae60; border: none; color: white; border-radius: 30px; margin-top: 10px; }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="score">Score: 0</div>
        <canvas id="gameCanvas"></canvas>
        <div id="game-over">
            <h1>CRASHED!</h1>
            <p id="final-score"></p>
            <button onclick="resetGame()">Play Again</button>
        </div>
    </div>

    <audio id="bgMusic" loop><source src="background-tone.mp3" type="audio/mpeg"></audio>
    <audio id="collisionSound"><source src="collision-tone.mp3" type="audio/mpeg"></audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, player;
        let obstacles = [];
        let score = 0;
        let isGameOver = false;
        let moveDirection = 0;
        let lastSpawnTime = 0;
        const spawnInterval = 650;

        const playerImageUrl = 'player.png'; 
        // Yahan aap apne saare block images ke naam add kar sakte hain
        const blockImages = ['block.png', 'block1.png', 'block2.png', 'block3.png']; 

        const bgMusic = document.getElementById('bgMusic');
        const collisionSound = document.getElementById('collisionSound');
        const loader = new THREE.TextureLoader();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            const playerGeometry = new THREE.PlaneGeometry(1, 1);
            const playerMaterial = new THREE.MeshBasicMaterial({ 
                map: loader.load(playerImageUrl), 
                transparent: true 
            });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.y = -3;
            scene.add(player);

            camera.position.z = 5;

            window.addEventListener('keydown', (e) => {
                if(e.key === "ArrowLeft") moveDirection = -1;
                if(e.key === "ArrowRight") moveDirection = 1;
                if (bgMusic.paused) bgMusic.play();
            });
            window.addEventListener('keyup', () => moveDirection = 0);

            window.addEventListener('touchstart', (e) => {
                if (bgMusic.paused) bgMusic.play();
                const touchX = e.touches[0].clientX;
                moveDirection = (touchX < window.innerWidth / 2) ? -1 : 1;
            });
            window.addEventListener('touchend', () => moveDirection = 0);

            animate(0);
        }

        function spawnObstacle() {
            // Randomly ek image select karega array se
            const randomBlockImg = blockImages[Math.floor(Math.random() * blockImages.length)];
            
            const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.1);
            const material = new THREE.MeshBasicMaterial({ 
                map: loader.load(randomBlockImg), 
                transparent: true 
            });
            const obstacle = new THREE.Mesh(geometry, material);
            
            obstacle.position.x = (Math.random() * 4) - 2; 
            obstacle.position.y = 6;
            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        function animate(currentTime) {
            if (isGameOver) return;
            requestAnimationFrame(animate);

            if (currentTime - lastSpawnTime > spawnInterval) {
                spawnObstacle();
                lastSpawnTime = currentTime;
            }

            if (moveDirection === -1 && player.position.x > -2.2) {
                player.position.x -= 0.12;
            } else if (moveDirection === 1 && player.position.x < 2.2) {
                player.position.x += 0.12;
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].position.y -= 0.1;

                const playerBox = new THREE.Box3().setFromObject(player);
                const blockBox = new THREE.Box3().setFromObject(obstacles[i]);

                if (playerBox.intersectsBox(blockBox)) {
                    endGame();
                }

                if (obstacles[i].position.y < -5) {
                    scene.remove(obstacles[i]);
                    obstacles.splice(i, 1);
                    score++;
                    document.getElementById('score').innerText = `Score: ${score}`;
                }
            }
            renderer.render(scene, camera);
        }

        function endGame() {
            isGameOver = true;
            bgMusic.pause();
            collisionSound.play();
            document.getElementById('final-score').innerText = `Score: ${score}`;
            document.getElementById('game-over').style.display = 'block';
        }

        function resetGame() {
            location.reload();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>